<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="/style.css">
  
  <title>  The new blog engine  </title>
</head>

<body>
  <div id='main'>
  <div id='content'>

<header>
  <a href="/">posts</a>
  | <a href="/tags/">tags</a>
  | <a href="/links/">links</a>
</header>

<h1 class="title">The new blog engine</h1>

<div><em>Tags:
<a href="/tags/cs/blog/">cs/blog</a>, <a href="/tags/cs/rust/">cs/rust</a>
| 2023-05-15
</em></div>

<p>GitHub started supporting custom code for generating static pages after I started my blog in 2015, so now I have more options for a blog engine.
I initially set up a Zola generator, which worked for the standard posts.
Zola doesn't have any plugin support though, and I wanted to add a bookmarks page, which would use a different page generator.
The links would be written down in a compact <a href="/implicit-data-markup">IDM</a> document and then a JavaScript-enhanced HTML bookmark page would be generated from it.
Any code dealing with IDM needs to be a custom thing written by me.
The Zola workflow couldn't support this, so I ended up writing a clumsy two-phase GitHub action that generated both the Zola site and my own bespoke bookmark page.</p>
<p>The bookmark generator turned out to be a surprisingly simple affair using IDM deserialization, <code>std::convert::From</code> conversion and <a href="https://github.com/djc/askama">Askama</a> templating.
I started thinking about ditching Zola and generating the entire site from IDM using my own code.</p>
<pre><code>        idm::from_str    convert::From         Template::render
 +----------+ |  +----------+ |  +------------------+    +-------------+
 | IDM text |---&gt;| IDM data |---&gt;|  template data   |-/-&gt;| static HTML |
 +----------+    +----------+    +------------------+ |  +-------------+
                                             +------------------+
                                             | Askama templates |
                                             +------------------+
</code></pre>
<p>An insight that helped with this was that I could print out an entire directory as an outline with file and directory names as headlines and file contents indented under the file name headline.
Fixed file or directory names in this scheme correspond to struct field names in the site datatype when the whole directory is printed out as an outline and deserialized with IDM.</p>
<p>Using the generic directory-to-outline routine, printing the following directory tree,</p>
<pre><code>site/posts/one-post.md:
  Lorem ipsum dolor sit amet,
  consectetur adipiscing elit,
site/posts/another-post.md
  Ut enim ad minim veniam,
  quis nostrud exercitation ullamco
site/links.idm:
  https://example.com/
    :title Example bookmark
</code></pre>
<p>produces the following IDM outline,</p>
<pre><code>posts
  one-post
    Lorem ipsum dolor sit amet,
    consectetur adipiscing elit,
  another-post
    Ut enim ad minim veniam,
    quis nostrud exercitation ullamco
links
  https://example.com/
    :title Example bookmark
</code></pre>
<p>which deserializes into the following Rust type (assuming suitable <code>Blogpost</code> and <code>Link</code> types),</p>
<pre><code>struct Site {
  posts: IndexMap&lt;String, Blogpost&gt;,
  links: IndexMap&lt;String, Link&gt;,
}
</code></pre>
<p>The site directory deserializes to an initial input struct that matches the structure of the IDM data exactly.
This needs to be converted into an output struct that contains derived information like lists of posts by tag and can drive Askama templates.
The conversion is straightforward and is implemented with Rust's standard <code>From</code> trait.
The HTML and Atom feed pages for the static site are then generated by rendering the Askama templates associated with the output types.
The entire site generator runs mostly on type definitions and involves little actual code.</p>
<p>Blog posts are written in Markdown, so how does everything being in IDM work with this? IDM's indent based structure provides a convenient multi-line string escape syntax, where an entire indented region can be treated as having a different syntax up until the next dedentation.
The blog post files have metadata fields in the colon-prefixed header block and the rest of the content is interpreted as Markdown text.
When the deserialized input structs are converted to output structs, the Markdown text is converted to HTML with the <code>pulldown-cmark</code> crate.</p>
<p>The whole site is now being generated using this system which was first developed for just the bookmarks page.
The blog generation works fine, and any new features can be easily added by extending the IDM site schema and the <code>From</code>-conversion methods.
For example, for the <a href="/project-outlines">project outlines</a> post, I wanted to be able to publish a raw outline instead of a Markdown post, so I added a <code>format</code> field to the post metadata struct, set it to default to <code>Markdown</code> so none of the existing posts needed to be touched, and set it to <code>Outline</code> for the new post.
Then I wrote a new HTML converter by hand for the outline format and I had a brand new style option for my blogposts.</p>
<p>The source code for the blog engine can be found in the <a href="https://github.com/rsaarelm/rsaarelm.github.io">repository of my blog</a>.</p>
  
  
  
  </div>
  
  <div id='footer'>
    <a type="application/atom+xml" rel="alternate" href="/feed.xml"><img src="/feed.png" alt="Atom feed"></a>
    &nbsp;
    <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src="/by-nc-sa.png" alt="cc-by-sa"></a>
  
  </div>
  
  </div>
</body>
</html>
